{
	"name": "Ingest_test",
	"properties": {
		"activities": [
			{
				"name": "File Size Validation",
				"type": "GetMetadata",
				"dependsOn": [
					{
						"activity": "Atomic Identity Resolution",
						"dependencyConditions": [
							"Succeeded"
						]
					}
				],
				"policy": {
					"timeout": "0.12:00:00",
					"retry": 2,
					"retryIntervalInSeconds": 30,
					"secureOutput": false,
					"secureInput": false
				},
				"userProperties": [],
				"typeProperties": {
					"dataset": {
						"referenceName": "DS_tenant1Sink",
						"type": "DatasetReference",
						"parameters": {
							"companyFolder": {
								"value": "@pipeline().parameters.sub_path",
								"type": "Expression"
							},
							"fileName": {
								"value": "@pipeline().parameters.file_name",
								"type": "Expression"
							}
						}
					},
					"fieldList": [
						"size",
						"lastModified",
						"exists",
						"contentMD5"
					],
					"storeSettings": {
						"type": "AzureBlobStorageReadSettings",
						"recursive": true,
						"enablePartitionDiscovery": false
					},
					"formatSettings": {
						"type": "BinaryReadSettings"
					}
				}
			},
			{
				"name": "File Size Validation Check",
				"type": "IfCondition",
				"dependsOn": [
					{
						"activity": "File Size Validation",
						"dependencyConditions": [
							"Completed"
						]
					}
				],
				"userProperties": [],
				"typeProperties": {
					"expression": {
						"value": "@and(equals(activity('File Size Validation').Status, 'Succeeded'), lessOrEquals(activity('File Size Validation').output.size, pipeline().parameters.max_file_size_bytes))",
						"type": "Expression"
					},
					"ifFalseActivities": [
						{
							"name": "Log File Size Error and Mark Failed",
							"type": "Script",
							"dependsOn": [],
							"policy": {
								"timeout": "0.12:00:00",
								"retry": 0,
								"retryIntervalInSeconds": 30,
								"secureOutput": false,
								"secureInput": false
							},
							"userProperties": [],
							"linkedServiceName": {
								"referenceName": "SnowflakeCN",
								"type": "LinkedServiceReference"
							},
							"typeProperties": {
								"scripts": [
									{
										"type": "NonQuery",
										"text": {
											"value": "-- Log the validation error\nINSERT INTO JAVATEST.JAVATEST1.PIPELINE_EXECUTION_LOG\n(LOG_ID, PIPELINE_NAME, PIPELINE_RUN_ID, STATUS, ERROR_TIME, TENANT_ID, COMPANY_ID, FILE_PATH, MESSAGE, ERROR_DETAILS)\nSELECT \n  UUID_STRING(),\n  'Ingest_test',\n  '@{pipeline().RunId}',\n  'VALIDATION_ERROR',\n  CURRENT_TIMESTAMP(),\n  '@{pipeline().parameters.tenant_id}',\n  '@{pipeline().parameters.company_id}',\n  '@{concat(pipeline().parameters.sub_path, '/', pipeline().parameters.file_name)}',\n  'File size validation failed - pipeline terminated',\n  OBJECT_CONSTRUCT('validationStatus', '@{activity('File Size Validation').Status}', 'maxAllowed', @{pipeline().parameters.max_file_size_bytes});\n\n-- Mark file as failed in queue\nINSERT INTO JAVATEST.JAVATEST1.MDB_INGEST_QUEUE\n(QUEUE_ID, RELATIVE_PATH, SIZE_BYTES, LAST_MODIFIED, STATUS, ATTEMPTS, ENQUEUED_AT, ERROR, FINISHED_AT, TENANT_ID, COMPANY_ID, TENANT_NAME, COMPANY_NAME)\nSELECT\n  UUID_STRING(),\n  '@{concat(pipeline().parameters.sub_path, '/', pipeline().parameters.file_name)}',\n  0,\n  CURRENT_TIMESTAMP(),\n  'FAILED_VALIDATION',\n  0,\n  CURRENT_TIMESTAMP(),\n  OBJECT_CONSTRUCT('errorType', 'FILE_SIZE_VALIDATION', 'errorMessage', 'File size validation failed'),\n  CURRENT_TIMESTAMP(),\n  0, -- Tenant ID not available in error scenarios\n  0, -- Company ID not available in error scenarios\n  '@{pipeline().parameters.tenant_id}',\n  '@{pipeline().parameters.company_id}';",
											"type": "Expression"
										}
									}
								],
								"scriptBlockExecutionTimeout": "02:00:00"
							}
						}
					],
					"ifTrueActivities": []
				}
			},
			{
				"name": "Duplicate File Check",
				"type": "Lookup",
				"dependsOn": [
					{
						"activity": "File Size Validation Check",
						"dependencyConditions": [
							"Succeeded"
						]
					},
					{
						"activity": "Set Resolved Company ID",
						"dependencyConditions": [
							"Succeeded"
						]
					}
				],
				"policy": {
					"timeout": "0.12:00:00",
					"retry": 2,
					"retryIntervalInSeconds": 30,
					"secureOutput": false,
					"secureInput": false
				},
				"userProperties": [],
				"typeProperties": {
					"source": {
						"type": "SnowflakeV2Source",
						"query": {
							"value": "-- Content-based duplicate detection with fallback logic\nSELECT \n  COUNT(*) as duplicate_count,\n  MAX(RELATIVE_PATH) as existing_file_path,\n  MAX(ENQUEUED_AT) as last_processed\nFROM JAVATEST.JAVATEST1.MDB_INGEST_QUEUE \nWHERE (\n    -- Primary: MD5-based detection (most accurate)\n    (MD5 IS NOT NULL \n     AND '@{activity('File Size Validation').output.contentMD5}' IS NOT NULL \n     AND MD5 = '@{activity('File Size Validation').output.contentMD5}'\n    )\n    OR\n    -- Fallback: Size + last modified + tenant/company (when MD5 unavailable)\n    (MD5 IS NULL \n     AND SIZE_BYTES = @{activity('File Size Validation').output.size}\n     AND ABS(DATEDIFF('second', LAST_MODIFIED, TO_TIMESTAMP_NTZ('@{activity('File Size Validation').output.lastModified}'))) <= 60\n    )\n  )\n  AND TENANT_ID = @{activity('Atomic Identity Resolution').output.resultSets[0].rows[0].RESOLVED_TENANT_ID}\n  AND COMPANY_ID = @{activity('Atomic Identity Resolution').output.resultSets[0].rows[0].RESOLVED_COMPANY_ID}\n  AND STATUS IN ('QUEUED', 'PROCESSING', 'COMPLETED')\n  AND ENQUEUED_AT >= DATEADD('day', -7, CURRENT_TIMESTAMP())\nFOR UPDATE;",
							"type": "Expression"
						},
						"exportSettings": {
							"type": "SnowflakeExportCopyCommand"
						}
					},
					"dataset": {
						"referenceName": "SnowflakeLookup",
						"type": "DatasetReference"
					}
				}
			},
			{
				"name": "Duplicate File Validation",
				"type": "IfCondition",
				"dependsOn": [
					{
						"activity": "Duplicate File Check",
						"dependencyConditions": [
							"Succeeded"
						]
					}
				],
				"userProperties": [],
				"typeProperties": {
					"expression": {
						"value": "@equals(activity('Duplicate File Check').output.firstRow.DUPLICATE_COUNT, 0)",
						"type": "Expression"
					},
					"ifFalseActivities": [
						{
							"name": "Log Duplicate File Error and Mark Failed",
							"type": "Script",
							"dependsOn": [],
							"policy": {
								"timeout": "0.12:00:00",
								"retry": 0,
								"retryIntervalInSeconds": 30,
								"secureOutput": false,
								"secureInput": false
							},
							"userProperties": [],
							"linkedServiceName": {
								"referenceName": "SnowflakeCN",
								"type": "LinkedServiceReference"
							},
							"typeProperties": {
								"scripts": [
									{
										"type": "NonQuery",
										"text": {
											"value": "-- Log the validation error with enhanced duplicate information\nINSERT INTO JAVATEST.JAVATEST1.PIPELINE_EXECUTION_LOG\n(LOG_ID, PIPELINE_NAME, PIPELINE_RUN_ID, STATUS, ERROR_TIME, TENANT_ID, COMPANY_ID, FILE_PATH, MESSAGE, ERROR_DETAILS)\nVALUES (\n  UUID_STRING(),\n  'Ingest_test',\n  '@{pipeline().RunId}',\n  'VALIDATION_ERROR',\n  CURRENT_TIMESTAMP(),\n  '@{pipeline().parameters.tenant_id}',\n  '@{pipeline().parameters.company_id}',\n  '@{concat(pipeline().parameters.sub_path, '/', pipeline().parameters.file_name)}',\n  'Content-based duplicate file detected - pipeline terminated',\n  OBJECT_CONSTRUCT(\n    'errorType', 'CONTENT_DUPLICATE',\n    'duplicateCount', '@{activity('Duplicate File Check').output.firstRow.DUPLICATE_COUNT}',\n    'existingFilePath', '@{activity('Duplicate File Check').output.firstRow.EXISTING_FILE_PATH}',\n    'contentMD5', '@{activity('File Size Validation').output.contentMD5}',\n    'fileSize', '@{activity('File Size Validation').output.size}',\n    'lastProcessed', '@{activity('Duplicate File Check').output.firstRow.LAST_PROCESSED}'\n  )\n);\n\n-- DO NOT insert duplicate into queue - skip insertion entirely for true duplicates",
											"type": "Expression"
										}
									}
								],
								"scriptBlockExecutionTimeout": "02:00:00"
							}
						}
					],
					"ifTrueActivities": []
				}
			},
			{
				"name": "Business Rules Validation",
				"type": "Script",
				"dependsOn": [
					{
						"activity": "Duplicate File Validation",
						"dependencyConditions": [
							"Succeeded"
						]
					},
					{
						"activity": "Set Resolved Company ID",
						"dependencyConditions": [
							"Succeeded"
						]
					}
				],
				"policy": {
					"timeout": "0.12:00:00",
					"retry": 1,
					"retryIntervalInSeconds": 30,
					"secureOutput": false,
					"secureInput": false
				},
				"userProperties": [],
				"linkedServiceName": {
					"referenceName": "SnowflakeCN",
					"type": "LinkedServiceReference"
				},
				"typeProperties": {
					"scripts": [
						{
							"type": "Query",
							"text": {
								"value": "-- Business Rules Validation\nSELECT \n  CASE \n    WHEN NOT ENDSWITH('@{pipeline().parameters.file_name}', '.mdb') THEN 'Invalid file format: must be .mdb'\n    WHEN LENGTH('@{pipeline().parameters.tenant_id}') = 0 THEN 'Invalid tenant ID: cannot be empty'\n    WHEN LENGTH('@{pipeline().parameters.company_id}') = 0 THEN 'Invalid company ID: cannot be empty'\n    WHEN '@{activity('File Size Validation').output.lastModified}' < DATEADD('day', -30, CURRENT_TIMESTAMP()) THEN 'File too old: older than 30 days'\n    WHEN '@{activity('File Size Validation').output.lastModified}' > DATEADD('hour', 1, CURRENT_TIMESTAMP()) THEN 'File from future: invalid timestamp'\n    ELSE 'VALID'\n  END as validation_result,\n  '@{pipeline().parameters.file_name}' as file_name,\n  '@{pipeline().parameters.tenant_id}' as tenant_id,\n  '@{pipeline().parameters.company_id}' as company_id,\n  '@{activity('File Size Validation').output.size}' as file_size,\n  '@{activity('File Size Validation').output.lastModified}' as last_modified;",
								"type": "Expression"
							}
						}
					],
					"scriptBlockExecutionTimeout": "02:00:00"
				}
			},
			{
				"name": "Business Rules Check",
				"type": "IfCondition",
				"dependsOn": [
					{
						"activity": "Business Rules Validation",
						"dependencyConditions": [
							"Succeeded"
						]
					}
				],
				"userProperties": [],
				"typeProperties": {
					"expression": {
						"value": "@equals(activity('Business Rules Validation').output.resultSets[0].rows[0].validation_result, 'VALID')",
						"type": "Expression"
					},
					"ifFalseActivities": [
						{
							"name": "Log Business Rules Error",
							"type": "Script",
							"dependsOn": [],
							"policy": {
								"timeout": "0.12:00:00",
								"retry": 0,
								"retryIntervalInSeconds": 30,
								"secureOutput": false,
								"secureInput": false
							},
							"userProperties": [],
							"linkedServiceName": {
								"referenceName": "SnowflakeCN",
								"type": "LinkedServiceReference"
							},
							"typeProperties": {
								"scripts": [
									{
										"type": "NonQuery",
										"text": {
											"value": "-- Log the validation error\nINSERT INTO JAVATEST.JAVATEST1.PIPELINE_EXECUTION_LOG\n(LOG_ID, PIPELINE_NAME, PIPELINE_RUN_ID, STATUS, ERROR_TIME, TENANT_ID, COMPANY_ID, FILE_PATH, MESSAGE, ERROR_DETAILS)\nSELECT \n  UUID_STRING(),\n  'Ingest_test',\n  '@{pipeline().RunId}',\n  'VALIDATION_ERROR',\n  CURRENT_TIMESTAMP(),\n  '@{pipeline().parameters.tenant_id}',\n  '@{pipeline().parameters.company_id}',\n  '@{concat(pipeline().parameters.sub_path, '/', pipeline().parameters.file_name)}',\n  'Business rules validation failed - pipeline terminated',\n  OBJECT_CONSTRUCT('validationResult', '@{activity('Business Rules Validation').output.resultSets[0].rows[0].validation_result}');\n\n-- Mark file as failed in queue\nINSERT INTO JAVATEST.JAVATEST1.MDB_INGEST_QUEUE\n(QUEUE_ID, RELATIVE_PATH, SIZE_BYTES, LAST_MODIFIED, STATUS, ATTEMPTS, ENQUEUED_AT, ERROR, FINISHED_AT, TENANT_ID, COMPANY_ID, TENANT_NAME, COMPANY_NAME)\nSELECT\n  UUID_STRING(),\n  '@{concat(pipeline().parameters.sub_path, '/', pipeline().parameters.file_name)}',\n  0,\n  CURRENT_TIMESTAMP(),\n  'FAILED_VALIDATION',\n  0,\n  CURRENT_TIMESTAMP(),\n  OBJECT_CONSTRUCT('errorType', 'BUSINESS_RULES', 'errorMessage', 'Business rules validation failed', 'validationResult', '@{activity('Business Rules Validation').output.resultSets[0].rows[0].validation_result}'),\n  CURRENT_TIMESTAMP(),\n  0, -- Tenant ID not available in error scenarios\n  0, -- Company ID not available in error scenarios\n  '@{pipeline().parameters.tenant_id}',\n  '@{pipeline().parameters.company_id}';",
											"type": "Expression"
										}
									}
								],
								"scriptBlockExecutionTimeout": "02:00:00"
							}
						}
					],
					"ifTrueActivities": [
						{
							"name": "Log Validation Success",
							"type": "Script",
							"dependsOn": [],
							"policy": {
								"timeout": "0.12:00:00",
								"retry": 2,
								"retryIntervalInSeconds": 30,
								"secureOutput": false,
								"secureInput": false
							},
							"userProperties": [],
							"linkedServiceName": {
								"referenceName": "SnowflakeCN",
								"type": "LinkedServiceReference"
							},
							"typeProperties": {
								"scripts": [
									{
										"type": "NonQuery",
										"text": {
											"value": "INSERT INTO JAVATEST.JAVATEST1.PIPELINE_EXECUTION_LOG\n(LOG_ID, PIPELINE_NAME, PIPELINE_RUN_ID, STATUS, START_TIME, TENANT_ID, COMPANY_ID, FILE_PATH, MESSAGE, ERROR_DETAILS)\nSELECT \n  UUID_STRING(),\n  'Ingest_test',\n  '@{pipeline().RunId}',\n  'VALIDATION_PASSED',\n  CURRENT_TIMESTAMP(),\n  '@{pipeline().parameters.tenant_id}',\n  '@{pipeline().parameters.company_id}',\n  '@{concat(pipeline().parameters.sub_path, '/', pipeline().parameters.file_name)}',\n  'All pre-processing validations passed',\n  OBJECT_CONSTRUCT(\n    'fileSize', '@{activity('File Size Validation').output.size}',\n    'lastModified', '@{activity('File Size Validation').output.lastModified}',\n    'duplicateCheck', '@{activity('Duplicate File Check').output.firstRow.DUPLICATE_COUNT}',\n    'businessRulesResult', '@{activity('Business Rules Validation').output.resultSets[0].rows[0].validation_result}'\n  );",
											"type": "Expression"
										}
									}
								],
								"scriptBlockExecutionTimeout": "02:00:00"
							}
						}
					]
				}
			},
			{
				"name": "Ingest queue",
				"type": "Script",
				"dependsOn": [
					{
						"activity": "Business Rules Check",
						"dependencyConditions": [
							"Succeeded"
						]
					},
					{
						"activity": "Set Resolved Company ID",
						"dependencyConditions": [
							"Succeeded"
						]
					}
				],
				"policy": {
					"timeout": "0.12:00:00",
					"retry": 3,
					"retryIntervalInSeconds": 30,
					"secureOutput": false,
					"secureInput": false
				},
				"userProperties": [],
				"linkedServiceName": {
					"referenceName": "SnowflakeCN",
					"type": "LinkedServiceReference"
				},
				"typeProperties": {
					"scripts": [
						{
							"type": "NonQuery",
							"text": {
								"value": "-- Atomic insert with content-based duplicate prevention using existing MD5 column\n-- Insert only if content (MD5 + size + tenant/company) doesn't already exist\nINSERT INTO JAVATEST.JAVATEST1.MDB_INGEST_QUEUE\n(QUEUE_ID, RELATIVE_PATH, SIZE_BYTES, LAST_MODIFIED, STATUS, ATTEMPTS, ENQUEUED_AT, TENANT_ID, COMPANY_ID, TENANT_NAME, COMPANY_NAME, MD5)\nSELECT\n  UUID_STRING(),\n  '@{concat(pipeline().parameters.sub_path, '/', pipeline().parameters.file_name)}',\n  COALESCE(TRY_CAST('@{if(contains(string(activity('File Size Validation').output), 'size'), activity('File Size Validation').output.size, '0')}' AS NUMBER), 0),\n  COALESCE(TO_TIMESTAMP_NTZ('@{if(contains(string(activity('File Size Validation').output), 'lastModified'), activity('File Size Validation').output.lastModified, '')}'), CURRENT_TIMESTAMP()),\n  'QUEUED',\n  0,\n  CURRENT_TIMESTAMP(),\n  @{activity('Atomic Identity Resolution').output.resultSets[0].rows[0].RESOLVED_TENANT_ID},       \n  @{activity('Atomic Identity Resolution').output.resultSets[0].rows[0].RESOLVED_COMPANY_ID},      \n  '@{pipeline().parameters.tenant_id}',   \n  '@{pipeline().parameters.company_id}',\n  '@{activity('File Size Validation').output.contentMD5}'\nWHERE NOT EXISTS (\n  SELECT 1 FROM JAVATEST.JAVATEST1.MDB_INGEST_QUEUE existing\n  WHERE existing.MD5 = '@{activity('File Size Validation').output.contentMD5}'\n    AND existing.SIZE_BYTES = @{activity('File Size Validation').output.size}\n    AND existing.TENANT_ID = @{activity('Atomic Identity Resolution').output.resultSets[0].rows[0].RESOLVED_TENANT_ID}\n    AND existing.COMPANY_ID = @{activity('Atomic Identity Resolution').output.resultSets[0].rows[0].RESOLVED_COMPANY_ID}\n    AND existing.STATUS IN ('QUEUED', 'PROCESSING', 'COMPLETED')\n    AND existing.ENQUEUED_AT >= DATEADD('day', -7, CURRENT_TIMESTAMP())\n);\n",
								"type": "Expression"
							}
						}
					],
					"scriptBlockExecutionTimeout": "02:00:00"
				}
			},
			{
				"name": "Insert",
				"type": "Script",
				"dependsOn": [
					{
						"activity": "Ingest queue",
						"dependencyConditions": [
							"Completed"
						]
					}
				],
				"policy": {
					"timeout": "0.12:00:00",
					"retry": 2,
					"retryIntervalInSeconds": 60,
					"secureOutput": false,
					"secureInput": false
				},
				"userProperties": [],
				"linkedServiceName": {
					"referenceName": "SnowflakeCN",
					"type": "LinkedServiceReference"
				},
				"typeProperties": {
					"scripts": [
						{
							"type": "NonQuery",
							"text": {
								"value": "-- Update status to PROCESSING before calling stored procedure\nUPDATE JAVATEST.JAVATEST1.MDB_INGEST_QUEUE\nSET STATUS = 'PROCESSING', \n    ATTEMPTS = ATTEMPTS + 1\nWHERE RELATIVE_PATH = '@{concat(pipeline().parameters.sub_path, '/', pipeline().parameters.file_name)}'\n  AND STATUS = 'QUEUED';",
								"type": "Expression"
							}
						},
						{
							"type": "Query",
							"text": "CALL JAVATEST.JAVATEST1.PROC_INGEST_NEXT_MDB2()"
						}
					],
					"scriptBlockExecutionTimeout": "02:00:00"
				}
			},
			{
				"name": "dbt job call",
				"type": "WebActivity",
				"dependsOn": [
					{
						"activity": "Insert",
						"dependencyConditions": [
							"Completed"
						]
					}
				],
				"policy": {
					"timeout": "0.12:00:00",
					"retry": 0,
					"retryIntervalInSeconds": 30,
					"secureOutput": false,
					"secureInput": false
				},
				"userProperties": [],
				"typeProperties": {
					"method": "POST",
					"headers": {
						"Authorization": "Token dbtc_E6Qw_z80dL3U0sBjAh9Bsg_bZsgKRQ43mYbQoK0-lwLpDFj8ls",
						"Content-Type": "application/json"
					},
					"url": "https://gz086.us1.dbt.com/api/v2/accounts/70471823487150/jobs/70471823499473/run/",
					"body": {
						"cause": "Triggered via API"
					}
				}
			},
			{
				"name": "Truncate",
				"type": "Script",
				"state": "Inactive",
				"onInactiveMarkAs": "Succeeded",
				"dependsOn": [],
				"policy": {
					"timeout": "0.12:00:00",
					"retry": 0,
					"retryIntervalInSeconds": 30,
					"secureOutput": false,
					"secureInput": false
				},
				"userProperties": [],
				"linkedServiceName": {
					"referenceName": "SnowflakeCN",
					"type": "LinkedServiceReference"
				},
				"typeProperties": {
					"scripts": [
						{
							"type": "Query",
							"text": "TRUNCATE TABLE javatest.javatest1.CITIES;\nTRUNCATE TABLE javatest.javatest1.CURRENCIES;\nTRUNCATE TABLE javatest.javatest1.INVOICES;\nTRUNCATE TABLE javatest.javatest1.TINVOICES;\nTRUNCATE TABLE javatest.javatest1.OFFERS;\nTRUNCATE TABLE javatest.javatest1.TOFFERS;\nTRUNCATE TABLE javatest.javatest1.ITEMS;\nTRUNCATE TABLE javatest.javatest1.ITEMGROUP;\nTRUNCATE TABLE javatest.javatest1.EMPLOYEES;\nTRUNCATE TABLE javatest.javatest1.TEMPLOYEES;\nTRUNCATE TABLE javatest.javatest1.WAREHOUSES;\nTRUNCATE TABLE javatest.javatest1.CUSTOMERLIST;\nTRUNCATE TABLE javatest.javatest1.ITEMSTOCK;\nTRUNCATE TABLE javatest.javatest1.MATERIAL;\nTRUNCATE TABLE javatest.javatest1.MATERIALSTOCK;\nTRUNCATE TABLE javatest.javatest1.TITEMS;\nTRUNCATE TABLE javatest.javatest1.PARTNERS;\nTRUNCATE TABLE javatest.javatest1.TPARTNERS;\nTRUNCATE TABLE javatest.javatest1.BANK;\nTRUNCATE TABLE javatest.javatest1.ACCOUNTS;\nTRUNCATE TABLE javatest.javatest1.FISOPERATOR;\nTRUNCATE TABLE javatest.javatest1.INTCOUNTRY;\n"
						}
					],
					"scriptBlockExecutionTimeout": "02:00:00"
				}
			},
			{
				"name": "Atomic Identity Resolution",
				"type": "Script",
				"dependsOn": [],
				"policy": {
					"timeout": "0.12:00:00",
					"retry": 2,
					"retryIntervalInSeconds": 30,
					"secureOutput": false,
					"secureInput": false
				},
				"userProperties": [],
				"linkedServiceName": {
					"referenceName": "SnowflakeCN",
					"type": "LinkedServiceReference"
				},
				"typeProperties": {
					"scripts": [
						{
							"type": "Query",
							"text": {
								"value": "-- Single atomic operation: Create procedure and execute in one transaction\nBEGIN\n  -- Create the stored procedure (idempotent)\n  CREATE OR REPLACE PROCEDURE RESOLVE_TENANT_COMPANY_IDS(\n    TENANT_NAME STRING,\n    COMPANY_NAME STRING\n  )\n  RETURNS TABLE(RESOLVED_TENANT_ID NUMBER, RESOLVED_COMPANY_ID NUMBER)\n  LANGUAGE SQL\n  AS\n  $$\n  BEGIN\n    -- Upsert tenant\n    MERGE INTO JAVATEST.TONILO_WAREHOUSE.DIM_TENANT AS tgt\n    USING (SELECT TENANT_NAME AS tenant_name) AS src\n    ON tgt.tenant_name = src.tenant_name\n    WHEN NOT MATCHED THEN\n        INSERT (tenant_name, created_at) VALUES (src.tenant_name, CURRENT_TIMESTAMP());\n\n    -- Get tenant ID  \n    LET resolved_tenant_id := (\n      SELECT tenant_id FROM JAVATEST.TONILO_WAREHOUSE.DIM_TENANT \n      WHERE tenant_name = TENANT_NAME\n    );\n\n    -- Upsert company\n    MERGE INTO JAVATEST.TONILO_WAREHOUSE.DIM_COMPANY AS tgt\n    USING (SELECT resolved_tenant_id AS tenant_id, COMPANY_NAME AS company_name) AS src\n    ON tgt.tenant_id = src.tenant_id AND tgt.company_name = src.company_name\n    WHEN NOT MATCHED THEN\n        INSERT (tenant_id, company_name, created_at) \n        VALUES (src.tenant_id, src.company_name, CURRENT_TIMESTAMP());\n\n    -- Return both resolved IDs\n    RETURN TABLE(\n      SELECT \n        resolved_tenant_id as RESOLVED_TENANT_ID,\n        (\n          SELECT company_id \n          FROM JAVATEST.TONILO_WAREHOUSE.DIM_COMPANY\n          WHERE tenant_id = resolved_tenant_id AND company_name = COMPANY_NAME\n        ) as RESOLVED_COMPANY_ID\n    );\n  END;\n  $$;\n\n  -- Execute the procedure immediately and return results for ADF variables\n  CALL RESOLVE_TENANT_COMPANY_IDS('@{pipeline().parameters.tenant_id}', '@{pipeline().parameters.company_id}');\nEND;",
								"type": "Expression"
							}
						}
					],
					"scriptBlockExecutionTimeout": "02:00:00"
				}
			},
			{
				"name": "Log Pipeline Start",
				"type": "Script",
				"dependsOn": [
					{
						"activity": "Atomic Identity Resolution",
						"dependencyConditions": [
							"Succeeded"
						]
					}
				],
				"policy": {
					"timeout": "0.12:00:00",
					"retry": 0,
					"retryIntervalInSeconds": 30,
					"secureOutput": false,
					"secureInput": false
				},
				"userProperties": [],
				"linkedServiceName": {
					"referenceName": "SnowflakeCN",
					"type": "LinkedServiceReference"
				},
				"typeProperties": {
					"scripts": [
						{
							"type": "NonQuery",
							"text": {
								"value": "INSERT INTO JAVATEST.JAVATEST1.PIPELINE_EXECUTION_LOG\n(LOG_ID, PIPELINE_NAME, PIPELINE_RUN_ID, STATUS, START_TIME, TENANT_ID, COMPANY_ID, FILE_PATH, MESSAGE)\nSELECT\nUUID_STRING(), 'Ingest_test', '@{pipeline().RunId}', 'STARTED', CURRENT_TIMESTAMP(), '@{pipeline().parameters.tenant_id}', '@{pipeline().parameters.company_id}', '@{concat(pipeline().parameters.sub_path, '/', pipeline().parameters.file_name)}', 'Pipeline execution started'",
								"type": "Expression"
							}
						}
					],
					"scriptBlockExecutionTimeout": "02:00:00"
				}
			},
			{
				"name": "Log DBT Error",
				"type": "Script",
				"dependsOn": [
					{
						"activity": "dbt job call",
						"dependencyConditions": [
							"Failed"
						]
					}
				],
				"policy": {
					"timeout": "0.12:00:00",
					"retry": 0,
					"retryIntervalInSeconds": 30,
					"secureOutput": false,
					"secureInput": false
				},
				"userProperties": [],
				"linkedServiceName": {
					"referenceName": "SnowflakeCN",
					"type": "LinkedServiceReference"
				},
				"typeProperties": {
					"scripts": [
						{
							"type": "NonQuery",
							"text": {
								"value": "INSERT INTO JAVATEST.JAVATEST1.PIPELINE_EXECUTION_LOG\n(LOG_ID, PIPELINE_NAME, PIPELINE_RUN_ID, STATUS, ERROR_TIME, TENANT_ID, COMPANY_ID, FILE_PATH, MESSAGE, ERROR_DETAILS)\nSELECT\nUUID_STRING(), 'Ingest_test', '@{pipeline().RunId}', 'ERROR', CURRENT_TIMESTAMP(), '@{pipeline().parameters.tenant_id}', '@{pipeline().parameters.company_id}', '@{concat(pipeline().parameters.sub_path, '/', pipeline().parameters.file_name)}', 'DBT job failed', '@{activity('dbt job call').error.message}');\n\n\nUPDATE JAVATEST.JAVATEST1.MDB_INGEST_QUEUE\nSET \n  STATUS = 'DLQ',\n  ERROR = OBJECT_CONSTRUCT(\n    'errorType', 'DBT',\n    'errorMessage', '@{activity('dbt job call').error.message}',\n    'relativePath', RELATIVE_PATH,\n    'tenantId', TENANT_ID,\n    'companyId', COMPANY_ID\n  ),\n  FINISHED_AT = CURRENT_TIMESTAMP()\nWHERE RELATIVE_PATH = '@{concat(pipeline().parameters.sub_path, '/', pipeline().parameters.file_name)}';\n",
								"type": "Expression"
							}
						}
					],
					"scriptBlockExecutionTimeout": "02:00:00"
				}
			},
			{
				"name": "Log Pipeline Success",
				"type": "Script",
				"dependsOn": [
					{
						"activity": "dbt job call",
						"dependencyConditions": [
							"Succeeded"
						]
					}
				],
				"policy": {
					"timeout": "0.12:00:00",
					"retry": 0,
					"retryIntervalInSeconds": 30,
					"secureOutput": false,
					"secureInput": false
				},
				"userProperties": [],
				"linkedServiceName": {
					"referenceName": "SnowflakeCN",
					"type": "LinkedServiceReference"
				},
				"typeProperties": {
					"scripts": [
						{
							"type": "NonQuery",
							"text": {
								"value": "-- Log success and update queue status to COMPLETED\nINSERT INTO JAVATEST.JAVATEST1.PIPELINE_EXECUTION_LOG\n(LOG_ID, PIPELINE_NAME, PIPELINE_RUN_ID, STATUS, END_TIME, TENANT_ID, COMPANY_ID, FILE_PATH, MESSAGE)\nVALUES (\n  UUID_STRING(), \n  'Ingest_test', \n  '@{pipeline().RunId}', \n  'SUCCESS', \n  CURRENT_TIMESTAMP(), \n  '@{pipeline().parameters.tenant_id}', \n  '@{pipeline().parameters.company_id}', \n  '@{concat(pipeline().parameters.sub_path, '/', pipeline().parameters.file_name)}', \n  'Pipeline completed successfully'\n);\n\n-- Update queue status to COMPLETED\nUPDATE JAVATEST.JAVATEST1.MDB_INGEST_QUEUE\nSET STATUS = 'COMPLETED',\n    FINISHED_AT = CURRENT_TIMESTAMP()\nWHERE RELATIVE_PATH = '@{concat(pipeline().parameters.sub_path, '/', pipeline().parameters.file_name)}'\n  AND STATUS = 'PROCESSING';",
								"type": "Expression"
							}
						}
					],
					"scriptBlockExecutionTimeout": "02:00:00"
				}
			}
		],
		"parameters": {
			"relative_path": {
				"type": "string"
			},
			"tenant_id": {
				"type": "string"
			},
			"company_id": {
				"type": "string"
			},
			"file_name": {
				"type": "string"
			},
			"sub_path": {
				"type": "string"
			},
			"max_file_size_bytes": {
				"type": "int",
				"defaultValue": 1073741824
			},
			"max_file_age_days": {
				"type": "int",
				"defaultValue": 30
			},
			"enable_duplicate_check": {
				"type": "bool",
				"defaultValue": true
			},
			"enable_business_rules_validation": {
				"type": "bool",
				"defaultValue": true
			}
		},
		"variables": {},
		"annotations": [],
		"lastPublishTime": "2025-08-27T13:01:05Z"
	},
	"type": "Microsoft.DataFactory/factories/pipelines"
}